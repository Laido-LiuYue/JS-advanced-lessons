<!DOCTYPE html>
<html>
<head>
	<title>任务十</title>
	<meta charset="utf-8">
	<script type="text/javascript">
		//JS闭包
		//闭包的典型例子
		function f1(){
			var x = 1;
			function f2(){
				return x++;
    		}
			return f2;
		}
		var f3 = f1();
		console.log(f3());//1
		console.log(f3());//2

		/*闭包closure的概念
		闭包是由函数和与其相关的引用环境组合而成的实体
		闭包是词法作用域中的函数和其相关变量的包裹体*/
		function createInc(startValue){
			return function(step){
				startValue+=step;
				return startValue;
    		}
		}
		var inc = createInc(5);
		console.log(inc(1));//6
		console.log(inc(2));//8

		/*一个函数离开了它被创建时的作用域,它还是会与这个作用域的变量相关联
		闭包是一个函数外加上该函数创建时所建立的作用域*/
		function foo() {
    		var i = 0;
    		function bar() {
        		console.log(++i);
    		}
    		return bar;
		}
		var a = foo();
		var b = foo();
		a();//1
		a();//2
		b();//1

		//闭包的常见形式（以函数对象形式返回
		var tmp = 100;
		function foo(x) {
    		var tmp = 3;
    		return function (y) {
        		console.log(x + y + (++tmp));
    		}
		}
		var fee = foo(2);
		fee(10);//16
		fee(10);//17
		fee(10);//18

		//作为对象的方法返回
		function counter() {
    		var n = 0;
    		return {
        		count:function () {return ++n;},
        		reset:function () {n = 0;return n;}
    		}
		}
		var c = counter();
		var d = counter();
		console.log(c.count());//1
		console.log(d.count());//1
		console.log(c.reset());//0
		console.log(c.count());//1
		console.log(d.count());//2


		//闭包的作用
		/*可通过闭包来访问隐藏在函数作用域内的局部变量
		使函数中的变量被保存在内存中不被释放（单例模式）
		*/
		function f1(){
    		var n = 999;
    		function f2(){
        		console.log(++n);
    		}
    		return f2;
		}
		var f = f1();
		f();//1000
		f();//1001
	</script>
</head>
<body>

</body>
</html>